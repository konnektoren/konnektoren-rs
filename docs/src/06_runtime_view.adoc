ifndef::imagesdir[:imagesdir: ../images]

[[section-runtime-view]]
== Runtime View

ifdef::arc42help[]
[role="arc42help"]
****
.Contents
The runtime view describes concrete behavior and interactions of the systemâ€™s building blocks in form of scenarios from the following areas:

* important use cases or features: how do building blocks execute them?
* interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems?
* operation and administration: launch, start-up, stop
* error and exception scenarios

Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their *architectural relevance*. It is *not* important to describe a large number of scenarios. You should rather document a representative selection.

.Motivation
You should understand how (instances of) building blocks of your system perform their job and communicate at runtime.
You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view).

.Form
There are many notations for describing scenarios, e.g.

* numbered list of steps (in natural language)
* activity diagrams or flow charts
* sequence diagrams
* BPMN or EPCs (event process chains)
* state machines
* ...

.Further Information

See https://docs.arc42.org/section-6/[Runtime View] in the arc42 documentation.

****
endif::arc42help[]

=== Profile Update Scenario

This scenario demonstrates how a user updates their profile name, with data stored locally for privacy and offline support.

[plantuml, profile-update, png]
----
@startuml
actor User
participant WebApp as "Konnektoren Yew"
participant LocalStorage

User -> WebApp : Open Profile Page
User -> WebApp : Update Name
WebApp -> LocalStorage : Save Updated Name
LocalStorage --> WebApp : Confirm Save
WebApp -> User : Display Success Message
@enduml
----

**Steps:**

1. User opens the profile page in the Konnektoren Yew web app.
2. User updates their name.
3. WebApp saves the updated name in browser local storage.
4. LocalStorage confirms the save.
5. WebApp displays a success message.

**Architectural relevance:**
Demonstrates privacy-preserving local data management and immediate UI feedback.

=== Challenge Selection Scenario

This scenario shows how a user selects a challenge on the map, with access control and error handling.

[plantuml, user-selects-challenge, png]
----
@startuml
actor User
participant WebApp as "Konnektoren Yew"
participant Core as "Konnektoren Core"
participant LocalStorage

User -> WebApp : Open Map Page
WebApp -> Core : Load User Profile & Game State
Core -> LocalStorage : Retrieve Data
LocalStorage --> Core : Return Data
Core --> WebApp : Send Data
WebApp -> User : Display Map

User -> WebApp : Select Challenge
WebApp -> Core : Check Challenge Requirements
alt Challenge Locked
    Core -> WebApp : Error: Challenge Locked
    WebApp -> User : Show Error Dialog
else Challenge Unlocked
    Core -> WebApp : Send Challenge Info
    WebApp -> User : Show Challenge Info
    User -> WebApp : Start Challenge
    WebApp -> User : Redirect to Challenge
end
@enduml
----

**Steps:**

1. User opens the map page.
2. WebApp requests profile and game state from Core.
3. Core retrieves data from LocalStorage.
4. Data flows back to WebApp, which displays the map.
5. User selects a challenge.
6. WebApp checks requirements with Core.
7. If locked, error is shown; if unlocked, challenge info is displayed and user can start the challenge.

**Architectural relevance:**
Shows access control, error handling, and data flow between frontend, core logic, and local storage.

=== Challenge Participation Scenario

This scenario covers the full flow of a user participating in a challenge, including evaluation and awarding points.

[plantuml, challenge-participation, png]
----
@startuml
actor User
participant WebApp as "Konnektoren Yew"
participant Core as "Konnektoren Core"
participant ChallengeConfig as "Challenge Config"
participant ChallengeModule as "Challenge Module"
participant UserProfile

User -> WebApp : Start Challenge
WebApp -> Core : Request Challenge Data
Core -> ChallengeConfig : Get Questions
ChallengeConfig --> Core : Return Questions
Core -> WebApp : Send Challenge Data
WebApp -> User : Show Questions

User -> WebApp : Submit Answers
WebApp -> Core : Send Answers
Core -> ChallengeModule : Evaluate Answers
ChallengeModule --> Core : Return Results
Core -> WebApp : Send Results
WebApp -> User : Show Results

WebApp -> Core : Award Points
Core -> UserProfile : Update Points
UserProfile --> Core : Confirm Update
Core -> WebApp : Confirm Points Awarded
WebApp -> User : Show Points Awarded
@enduml
----

**Steps:**

1. User starts a challenge.
2. Challenge data is loaded and displayed.
3. User submits answers.
4. Answers are evaluated; results are returned and shown.
5. Points are awarded and user profile is updated.

**Architectural relevance:**
Demonstrates modular evaluation, state updates, and feedback loop.

=== Leaderboard and Certificate Scenario

This scenario illustrates how a user claims a certificate and interacts with the leaderboard.

[plantuml, leaderboard-certificate, png]
----
@startuml
actor User
participant WebApp as "Konnektoren Yew"
participant Core as "Konnektoren Core"
participant CertificateModule as "Certificate Module"
participant LeaderboardModule as "Leaderboard Module"
participant BackendAPI as "Konnektoren API"

User -> WebApp : Visit Profile Page
WebApp -> Core : Request Profile Data
Core -> WebApp : Send Profile Data
WebApp -> User : Show Profile

User -> WebApp : Claim Certificate
WebApp -> CertificateModule : Generate Certificate
CertificateModule --> WebApp : Return Certificate Data

WebApp -> Core : Store Certificate Data
Core -> BackendAPI : Store Data
BackendAPI --> Core : Confirm Storage
Core -> WebApp : Confirm Certificate Stored
WebApp -> User : Show Certificate

User -> WebApp : Visit Leaderboard
WebApp -> Core : Request Leaderboard Data
Core -> BackendAPI : Get Top Performances
BackendAPI --> Core : Return Data
Core -> WebApp : Send Leaderboard Data
WebApp -> User : Show Leaderboard
@enduml
----

**Steps:**

1. User views profile and claims certificate.
2. Certificate is generated and stored via backend API.
3. User views leaderboard, which is fetched from backend.

**Architectural relevance:**
Shows integration with backend APIs, certificate generation, and leaderboard data flow.

=== Verifiable Credential Issuance Scenario

This scenario demonstrates how a user receives a verifiable credential (badge) after completing challenges.

[plantuml, vc-issuance-c4, png]
----
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

Person(user, "User", "Learner")
System_Boundary(konnektoren, "Konnektoren System") {
    Container(frontend, "Frontend", "Yew/WebAssembly", "Web interface")
    Container(core, "Core", "Rust", "Business logic")
}
System_Ext(vc_issuer, "vc.konnektoren.help", "Credential Issuer")

Rel(user, frontend, "Completes challenges")
Rel(frontend, core, "Verifies completion")
Rel(core, frontend, "Confirms achievement")
Rel(frontend, vc_issuer, "Requests credential", "HTTPS")
Rel(vc_issuer, frontend, "Issues credential", "OpenID4VC")
Rel(frontend, user, "Displays QR code for credential")
@enduml
----

**Steps:**

1. User completes challenges.
2. Frontend verifies completion with Core.
3. Achievement is confirmed.
4. Frontend requests credential from external issuer.
5. Credential is issued via OpenID4VC.
6. Frontend displays QR code for user to claim badge.

**Architectural relevance:**
Highlights SSI integration and secure credential issuance.

=== Event and Command Handling Scenario

This scenario shows how the EventBus and CommandBus decouple actions and notifications in the system.

[plantuml, event-command-scenario, png]
----
@startuml
participant "User Interface" as UI
participant "Game Logic" as Game
participant "EventBus" as EB
participant "CommandBus" as CB
participant "Challenge Module" as CM

UI -> CB : Publish(NextChallengeCommand)
CB -> Game : Execute(NextChallengeCommand)
Game -> CM : Load Next Challenge
CM --> Game : Challenge Loaded
Game -> EB : Publish(ChallengeLoadedEvent)
EB -> UI : Notify(ChallengeLoadedEvent)
UI -> User : Update Display
@enduml
----

**Steps:**

1. UI publishes a command to CommandBus.
2. CommandBus executes the command via Game Logic.
3. Game Logic loads the next challenge.
4. Game Logic publishes an event to EventBus.
5. EventBus notifies UI, which updates the display.

**Architectural relevance:**
Demonstrates modular, event-driven architecture for maintainability and extensibility.

=== Game Controller Interaction Scenario

This scenario demonstrates how the GameController manages state and coordinates commands, events, and persistence.

[plantuml, game-controller-interaction, png]
----
@startuml
participant "Client" as C
participant "GameController" as GC
participant "CommandBus" as CB
participant "EventBus" as EB
participant "GameState" as GS
participant "Persistence" as P

C -> GC: publish_command(NextChallengeCommand)
GC -> CB: publish(NextChallengeCommand)
CB -> GC: handle_command(NextChallengeCommand)
GC -> GS: execute(NextChallengeCommand)
GS --> GC: state updated
GC -> EB: publish(ChallengeChangedEvent)
GC -> P: save_game_state()
P --> GC: state saved
EB --> C: notify(ChallengeChangedEvent)
@enduml
----

**Steps:**

1. Client publishes a command to GameController.
2. GameController forwards to CommandBus.
3. CommandBus calls back to GameController to handle the command.
4. GameController updates GameState.
5. GameController publishes an event to EventBus.
6. GameController saves state via Persistence.
7. EventBus notifies Client of the state change.

**Architectural relevance:**
Shows orchestration of state, events, and persistence for robust game management.
